local wrap_thread = require "hussar.wrap_thread"

describe("wrap_thread", function()
    it("can wrap a function which will be run in a thread when wrapped function called", function()
        local target = function(...)
            assert.equals(2, select("#", ...))
            coroutine.yield('yes')
        end
        local wrapped = wrap_thread(target)
        local th, r = wrapped(1, 2)
        assert.equals('yes', r)
        assert.equals(type(th), "thread")
        assert.is_not.equals(coroutine.status(th), "dead")
        coroutine.resume(th)
        assert.equals(coroutine.status(th), "dead")
    end)
    it("will throw a error when first call is failed", function()
        local target = function()
            error("test")
        end
        local wrapped = wrap_thread(target)
        assert.has_error(function()
            wrapped()
        end)
    end)
    it("will throw a typed error when first call is failed", function()
        local terr = require "hussar.terr"
        local target = function()
            error("test")
        end
        local wrapped = wrap_thread(target)
        local _, e = pcall(wrapped)
        assert.is.True(terr.is(e))
        assert.is.truthy(string.match(e.r, "test$"))
        assert.equals("wrap_thread", e.k)
        assert.equals("firstcall_error", e.t)
    end)
    it("will return thread returned values if thread died without errors", function()
        local target = function() return 'test' end
        local wrapped = wrap_thread(target)
        local th, result = wrapped()
        assert.is.Nil(th)
        assert.equals('test', result)
    end)
end)
